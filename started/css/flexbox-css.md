# 伸缩布局

## 伸缩布局

> `display:flex`

### 主轴对齐

* 在伸缩布局中,默认情况下,水平方向是主轴,且主轴起始方向是伸缩容器的左边,伸缩项默认从主轴起点开始排列
* `flex-direction :更改主轴起点位置;`取值:
  * `row` : 默认
  * `row-reverse` : 从右至左
  * `column` : 从上至下
  * `column-reverse` : 从下至上

{% hint style="info" %}
侧轴永远垂直于主轴,当主轴的方向发生变化时, 侧轴也会发生变化;
{% endhint %}

### 侧轴对齐

* `justify-content : 修改主轴对齐方式;`取值:
  * `flex-start` : 默认 \(和主轴起点对齐\);
  * `flex-end` : 和主轴终点对齐;
  * `center` : 居中对齐
  * `space-between` : 两端对齐 ; 
  * `space-around` : 主轴每个子元素左右相同留白
* `align-items : 修改侧轴对齐方式;`取值:
  * `flex-start` : 默认 \(和主轴起点对齐\);
  * `flex-end` : 和主轴终点对齐;
  * `center` : 居中对齐;
  * `baseline`: 所有伸缩项中的基线在一条直线上对齐;
  * `stretch`\(拉伸对齐/等高对齐\): 让所有的伸缩项的高度变为侧轴的高度;

> 侧轴对比主轴来说没有两端对齐\(`space-between`\)和环绕对齐\(`space-around`\)

{% hint style="warning" %}
如果设置为拉伸对齐, 那么伸缩项不能设置高度 如果伸缩项设置了高度, 那么拉伸对齐就会失效
{% endhint %}

* `align-self : 修改单个伸缩项与侧轴的对其方式;`
  * 取值同`align-items`相同,控制范围不同,且书写位置不同
  * `align-items:` 是一次性控制所有伸缩项的对齐方式;\(写在容器\)
  * `align-self:`是单独的控制某一个伸缩项在侧轴上的对齐方式\(写在伸缩项\)

### 换行和换行对齐

> 默认情况下如果伸缩容器的一行放不下所有的伸缩项, 那么系统会自动等比压缩所有的伸缩项

* `flex-wrap : 控制伸缩项是否换行;`取值:
  * `nowrap` : 不换行\(默认\);
  * `wrap` : 放不下就换行 而不是等比压缩;
  * `wrap-reverse`: 放不下就换行 , 以行为单位进行反转;
* `align-content : 设置换行之后的对齐方式;`取值:
  * `flex-start:` 换行之后和侧轴的起点对齐, 一行接一行;
  * `flex-end`: 换行之后和侧轴的终点对齐, 将所有换行之后的内容当做一个整体来操作
  * `center`: 换行之后和侧轴的中点对齐
  * `space-between:` 换行之后在侧轴上两端对齐
  * `space-around:` 换行之后在侧轴上环绕对齐
  * `stretch`: 以行为单位进行拉伸, 拉伸的部分以空白填充, 保证拉伸之后所有的行加起来能够填满侧轴

{% hint style="warning" %}
只有伸缩项发生了换行`align-content`这个属性才有效
{% endhint %}

### 伸缩项问题

#### 伸缩项排序

* `order : 决定伸缩项的排序;`
  * 默认情况下所有伸缩项的`order`属性的取值都是0;
  * `order`排序的规则: 从小到大的排序, 越小的显示在越前面, 越大的显示在越后面
* 
#### 伸缩项扩充

* `flex-grow :` 控制当所有伸缩项如何扩充自己, 以便所有伸缩项宽度的总和能够填满整个伸缩容器
  * 默认取值为0,表示不进行任何的扩充
  * 扩充公式:\(取值越大扩充越大\)

> 1. 利用伸缩容器宽度 - 所有伸缩项的宽度 = 剩余空间
> 2. 利用剩余空间 / 所有需要扩充份数的总和 = 每一份的大小
> 3. 利用当前伸缩项的宽度 + 需要的份数的宽度

#### 伸缩项缩小

* flex-shrink : 控制当所有伸缩项如何缩小自己, 以便于所有伸缩项宽度的总和能够填满整个伸缩容器;
  * 



